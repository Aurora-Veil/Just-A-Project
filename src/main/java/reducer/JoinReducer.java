package reducer;

import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
/**
 * Reducer class is typically responsible for aggregating, summarizing, or otherwise processing the intermediate data generated by the Mapper.
 * This class handle the aggregation and organization of different types of orders based on the information provided by the Mapper.
 * Input: <LongWritable, Text> - Input key-value pair.
 * Output: <NullWritable, Text> - Output key-value pair with NULL key and filtered trade records as the value.
 */

public class JoinReducer extends Reducer<LongWritable, Text, NullWritable, Text> {
    /**
     * Reduce input key-value pairs to intermediate key-value pairs.
     *
     * @param key     The input key.
     * @param values  The input value.
     * @param context The context object for emitting output.
     *                The output key is time, output value is composed by those useful fields in the original record in the format of final output.
     */

    /**
     * this Reducer's main task is to sort values with the same key,
     * based on timestamps and order sequence numbers, and output the sorted results.
    **/
    @Override
    protected void reduce(LongWritable key, Iterable<Text> values, Context context)
            throws IOException, InterruptedException {
        List<DataRecord> records = new ArrayList<>();

        // Iterate through values and store in a list
        for (Text value : values) {
            String[] fields = value.toString().split(",");
            String sequenceNumber = fields[5];
            records.add(new DataRecord(sequenceNumber, value.toString()));
        }

        // Custom sorting based on time and sequence number
        Collections.sort(records);

        // Output the sorted records
        for (DataRecord record : records) {
            context.write(NullWritable.get(), new Text(record.getData()));
        }
    }

    /*
    In the reduce method, the records list is sorted to ensure that the output is in ascending order based on time and sequence number.
     */
    private static class DataRecord implements Comparable<DataRecord> {
        private final String sequenceNumber;
        private final String data;

        public DataRecord(String sequenceNumber, String data) {
            this.sequenceNumber = sequenceNumber;
            this.data = data;
        }

        public String getData() {
            return data;
        }

        /*
        The compareTo method compares based on the sequenceNumber field in ascending order.
         */
        @Override
        public int compareTo(DataRecord other) {
            return Integer.compare(Integer.parseInt(this.sequenceNumber), Integer.parseInt(other.sequenceNumber));
        }
    }
}
