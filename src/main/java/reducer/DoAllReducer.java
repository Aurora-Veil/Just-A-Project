package reducer;

import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.output.MultipleOutputs;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

/**
 * Reducer class is typically responsible for aggregating, summarizing, or otherwise processing the intermediate data generated by the Mapper.
 * This class handle the aggregation and organization of different types of orders based on the information provided by the Mapper.
 * Input: <Text, Text> - Input key-value pair.
 * Output: <NullWritable, Text> - Output key-value pair with NULL key and filtered trade records as the value.
 */

public class DoAllReducer extends Reducer<Text, Text, NullWritable, Text> {

    private MultipleOutputs<NullWritable, Text> multipleOutputs;
    private Text outMarketValue = new Text();
    private Text outOrderValue = new Text();
    private Text outCancelValue = new Text();

    /**
     * Reduce input key-value pairs to intermediate key-value pairs.
     *
     * @param key     The input key.
     * @param values  The input value.
     * @param context The context object for emitting output.
     *                The output key is NULL, output value is composed by those useful fields in the original record in the format of final output.
     * @throws IOException          If an I/O error occurs.
     * @throws InterruptedException If the task is interrupted.
     */
    @Override
    protected void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException {
        /*
        These boolean variables ("IsCancel", "IsLimit", "IsSpec", "IsMarket")are used to track the presence of specific types of orders within the values associated with the key.
        The "distinctNumbers" is a "Set" used to keep track of distinct prices for Trade orders.
         */
        boolean IsCancel = false;
        boolean IsLimit = false;
        boolean IsSpec = false;
        boolean IsMarket = false;
        Set<Float> distinctNumbers = new HashSet<>();

        String Limit = "";
        String Spec = "";
        String Cancel = "";
        String Market = "";

        /*
        This loop iterates over the values associated with the key, examines the type of order, and updates the corresponding variables accordingly.
        For Trade orders, it extracts the price and adds it to the set of distinct numbers.
         */
        for (Text value : values) {
            String Title = value.toString().split(",")[0];
            switch (Title) {
                case "Cancel":
                    IsCancel = true;
                    Cancel = value.toString();
                    break;
                case "Spec":
                    IsSpec = true;
                    Spec = value.toString();
                    break;
                case "Limit":
                    IsLimit = true;
                    Limit = value.toString();
                    break;
                case "Market":
                    IsMarket = true;
                    Market = value.toString();
                    break;
                case "Trade":
                    float price = Float.parseFloat(value.toString().split(",")[2]);
                    distinctNumbers.add(price);
                    break;

            }

        }

        /*
        These conditional blocks check whether specific types of orders are present and perform corresponding processing.
            If there is a Market order,"CANCEL_TYPE" is 2, it extracts relevant fields, counts distinct "MARKET_ORDER_TYPE", and writes the output to the "MarketOrder" output.
            If there is a cancel order, it extracts relevant fields,and writes the output to the "Cancel" output.
            If there is a Limit order, it extracts relevant fields,and writes the output to the "LimitOrder" output.
            If there is a Spec order, it extracts relevant fields,and writes the output to the "LimitOrder" output.
        */
        if (IsMarket) {
            String[] fields = Market.split(",");
            int count = distinctNumbers.size();
            outMarketValue.set(fields[1] + "," + fields[2] + "," + fields[3] + "," + fields[4] + "," +
                    fields[5] + "," + fields[6] + "," + count + "," + "2");
            multipleOutputs.write("MarketOrder", NullWritable.get(), outMarketValue);
        }

        if (IsCancel) {
            outCancelValue.set(Cancel.substring(7));
            multipleOutputs.write("Cancel", NullWritable.get(), outCancelValue);
        }

        if (IsLimit) {
            outOrderValue.set(Limit.substring(6));
            multipleOutputs.write("LimitOrder", NullWritable.get(), outOrderValue);
        }

        if (IsSpec) {
            outOrderValue.set(Spec.substring(5));
            multipleOutputs.write("SpecOrder", NullWritable.get(), outOrderValue);
        }

    }

    //In the setup method, a MultipleOutputs object (multipleOutputs) is created and initialized.
    @Override
    protected void setup(Context context) {
        multipleOutputs = new MultipleOutputs<>(context);
    }

    //The cleanup method of the Reducer is responsible for closing the MultipleOutputs object.
    @Override
    protected void cleanup(Context context) throws IOException, InterruptedException {
        multipleOutputs.close();
    }
}
